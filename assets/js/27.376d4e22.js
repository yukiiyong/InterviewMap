(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{372:function(v,t,e){"use strict";e.r(t);var i=e(42),r=Object(i.a)({},(function(){var v=this,t=v.$createElement,e=v._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h4",{attrs:{id:"provide／inject与组件通信"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#provide／inject与组件通信"}},[v._v("#")]),v._v(" provide／inject与组件通信")]),v._v(" "),e("blockquote",[e("p",[v._v("适用于后代组件访问祖先组件")])]),v._v(" "),e("ol",[e("li",[v._v("这对选项需一起使用，以允许一个祖先组件向其所有子孙组件注入一个依赖，不管组件层级有多深，并在其上下游关系成立期间始终有效")]),v._v(" "),e("li",[v._v("若熟悉React，这与React的上下文特性十分类似")]),v._v(" "),e("li",[v._v("provide这个属性可以指定我们想提供给后代组件的数据或方法，而在任何后代组件中，我们都可以使用inject来接收provide提供的数据或方法")])]),v._v(" "),e("ul",[e("li",[v._v("Vue本身不会对provide中的变量进行响应式处理，若想inject接收的变量为响应式，那么"),e("strong",[v._v("provide提供的变量需为响应式")])]),v._v(" "),e("li",[v._v("将根组件中"),e("strong",[v._v("组件本身注入provide")]),v._v("，那么可以在后代组件中任意访问根组件中所有状态，那么"),e("strong",[v._v("根组件成了全局状态的容器")])])]),v._v(" "),e("h4",{attrs:{id:"为什么官方推荐vuex而不是provide／inject"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为什么官方推荐vuex而不是provide／inject"}},[v._v("#")]),v._v(" 为什么官方推荐vuex而不是provide／inject")]),v._v(" "),e("ol",[e("li",[v._v("vuex中的全局状态每次修改都是可以"),e("strong",[v._v("追踪回溯的")]),v._v("，而provide／inject中"),e("strong",[v._v("变量修改无法控制")]),v._v("（不知道哪个组件修改了状态）")]),v._v(" "),e("li",[v._v("provide／inject"),e("strong",[v._v("破坏了Vue单向数据流的原则")]),v._v("（除了.sync）。若有多个后代组件同时依赖于一个祖先组件，那么只要有一个组件修改了状态，所有后代组件"),e("strong",[v._v("都会收到影响")]),v._v("，使得数据不可控之余"),e("strong",[v._v("增加了耦合度")]),v._v("。")])]),v._v(" "),e("h4",{attrs:{id:"provide／inject做全局状态管理原则"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#provide／inject做全局状态管理原则"}},[v._v("#")]),v._v(" provide／inject做全局状态管理原则")]),v._v(" "),e("blockquote",[e("p",[v._v("更推荐用于编写组件")])]),v._v(" "),e("ol",[e("li",[v._v("多人协作时，做好作用域隔离。")]),v._v(" "),e("li",[v._v("尽量"),e("strong",[v._v("使用一次性数据")]),v._v("作全局状态")])])])}),[],!1,null,null,null);t.default=r.exports}}]);