(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{358:function(a,t,r){"use strict";r.r(t);var e=r(42),s=Object(e.a)({},(function(){var a=this,t=a.$createElement,r=a._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("h4",{attrs:{id:"大文件上传"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#大文件上传"}},[a._v("#")]),a._v(" 大文件上传")]),a._v(" "),r("ol",[r("li",[a._v("requestIdleCallback 空闲时间执行函数"),r("br"),a._v("\n将在浏览器空闲时调用的函数排队（macro task 和ui rendering后）"),r("br"),a._v("\nrequestIdleCallback执行的方法，会传入一个deadline参数，能够知道当前浏览器空闲时剩余的时间")]),a._v(" "),r("li",[a._v("时间分片计算hash（不卡顿主线程）"),r("br"),a._v("\n在浏览器空闲时执行workLoop，workLoop是在浏览器空闲时将每一个分了片的chunk通过FileReader读取，添加到spark中"),r("br"),a._v("\n而在浏览器忙碌时，会把它重新添加到在空闲时执行的函数队列中（requestIdleCallbak）")])]),a._v(" "),r("h4",{attrs:{id:"抽样hash"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#抽样hash"}},[a._v("#")]),a._v(" 抽样hash")]),a._v(" "),r("ol",[r("li",[a._v("计算文件md5，判断文件是否存在"),r("br"),a._v("\n1.1 文件切成2M大小的切片"),r("br"),a._v("\n1.2 取第一个和最后一个的全部内容，中间部分取首中尾三个地方各2个字节"),r("br"),a._v("\n1.3 合并之后的内容，计算md5"),r("br"),a._v("\n1.4 这个hash的结果，就是文件是否存在。（小概率误判，不准是100％）")])]),a._v(" "),r("h4",{attrs:{id:"网络请求并发数控制"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#网络请求并发数控制"}},[a._v("#")]),a._v(" 网络请求并发数控制")]),a._v(" "),r("ul",[r("li",[a._v("把异步请求放在一个队列中，设置一个并发数（如3），发起3个请求。然后有请求结束了就发起下一个请求，直到所有请求执行完毕")]),a._v(" "),r("li",[a._v("并发数max ： 发起一个请求max--，结束一个请求max++")])]),a._v(" "),r("h4",{attrs:{id:"慢-启动-策略实现"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#慢-启动-策略实现"}},[a._v("#")]),a._v(" 慢 启动 策略实现")]),a._v(" "),r("p",[a._v("根据当前网络情况，定一个初始大小，动态调整之后的切片大小")]),a._v(" "),r("ol",[r("li",[a._v("chunk加上size值，不过进度条数量不确定，修改createFileChunk，请求加上时间统计")]),a._v(" "),r("li",[a._v("比如理想是30秒传一个文件")]),a._v(" "),r("li",[a._v("初始大小定位1M，如第一个（之后也是）上传花了10秒（小于30秒，rate ＝ time／30 ，offset＝ parseInt（offset ／rate），那么下一个区块大小变成了3M")]),a._v(" "),r("li",[a._v("如果上传花了60秒，那么下一个区块大小变成500KB，以此类推")])]),a._v(" "),r("p",[r("strong",[a._v("进度条优化（类似于硬盘扫描）")]),a._v(" "),r("strong",[a._v("文件区块和并发数")])]),a._v(" "),r("h4",{attrs:{id:"错误处理（并发重试＋报错）"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#错误处理（并发重试＋报错）"}},[a._v("#")]),a._v(" 错误处理（并发重试＋报错）")]),a._v(" "),r("ol",[r("li",[a._v("请求出错catch把任务重新放到队列中")]),a._v(" "),r("li",[a._v("出错后progress设置为－1，进度条显示为红色")]),a._v(" "),r("li",[a._v("数组存储每个文件hash请求的重试次数，做累加。")])]),a._v(" "),r("ul",[r("li",[a._v("比如[0,1,2]就是第0 个文件出错一次，第二个文件出错2次。")])]),a._v(" "),r("ol",{attrs:{start:"4"}},[r("li",[a._v("一个请求出错超过3次直接reject")])]),a._v(" "),r("p",[r("strong",[a._v("清理碎片node_schedule")])])])}),[],!1,null,null,null);t.default=s.exports}}]);