(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{349:function(a,t,v){a.exports=v.p+"assets/img/scope_chain.efcfcd49.png"},373:function(a,t,v){"use strict";v.r(t);var _=v(42),s=Object(_.a)({},(function(){var a=this,t=a.$createElement,_=a._self._c||t;return _("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[_("h2",{attrs:{id:"javascript运行原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#javascript运行原理"}},[a._v("#")]),a._v(" JavaScript运行原理")]),a._v(" "),_("ol",[_("li",[a._v("JavaScript是解释性语言，无需提前编译，由解释器实时运行")]),a._v(" "),_("li",[a._v("JavaScript的程序执行主要分为语法检查和执行两个阶段。")]),a._v(" "),_("li",[a._v("语法检查包括词法分析，语法分析等，目的是将JS代码转换为抽象语法树，从而转换为字节码和机器码。")]),a._v(" "),_("li",[a._v("执行阶段分为预解析和执行阶段。")]),a._v(" "),_("li",[a._v("预解析阶段会创建执行上下文，将语法检查后生成的抽象语法树复制到当前的执行上下文，做属性填充，对抽象语法树中的变量声明、函数声明以及函数的形参作属性的填充。")])]),a._v(" "),_("h3",{attrs:{id:"引擎对js的处理流程（语法检查）"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#引擎对js的处理流程（语法检查）"}},[a._v("#")]),a._v(" 引擎对JS的处理流程（语法检查）")]),a._v(" "),_("ol",[_("li",[a._v("读取代码，对代码进行词法分析（lexical analysis），然后将代码分解成词元")]),a._v(" "),_("li",[a._v("将词元进行语法分析，然后将代码整理成语法树（syntax tree）")]),a._v(" "),_("li",[a._v("使用翻译器，将代码转换成字节码（bytecode）")]),a._v(" "),_("li",[a._v("将字节码用字节码解释器转成机器码，然后等待计算机执行")])]),a._v(" "),_("blockquote",[_("p",[a._v("为了提高运行速度，浏览器一般采用即时编译，即字节码只在运行时编译，用到哪一行编译哪一行，且把编译结果缓存。")])]),a._v(" "),_("blockquote",[_("p",[a._v("JS是弱类型，只在运行时检查数据类型")])]),a._v(" "),_("h3",{attrs:{id:"javascript预解析阶段"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#javascript预解析阶段"}},[a._v("#")]),a._v(" JavaScript预解析阶段")]),a._v(" "),_("ol",[_("li",[a._v("分号补全")]),a._v(" "),_("li",[a._v("变量提升：变量声明、函数声明")]),a._v(" "),_("li",[a._v("创建执行上下文")])]),a._v(" "),_("blockquote",[_("p",[a._v("预解析只发生在当前作用域下 ，即只有函数执行时才会对函数里的变量和函数进行预解析")])]),a._v(" "),_("h3",{attrs:{id:"分号补全规则"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#分号补全规则"}},[a._v("#")]),a._v(" 分号补全规则")]),a._v(" "),_("ol",[_("li",[a._v("当有换行符（且含有换行符的多行注释），并且下一个token无法与前面的语法匹配时，自动补分号。")]),a._v(" "),_("li",[a._v("当有'}'时，自动补分号")]),a._v(" "),_("li",[a._v("程序源代码结束时，自动补分号")])]),a._v(" "),_("h2",{attrs:{id:"执行上下文栈"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#执行上下文栈"}},[a._v("#")]),a._v(" 执行上下文栈")]),a._v(" "),_("p",[a._v("在JavaScript解释器运行阶段（预解析）维护了一个栈，用于管理执行上下文")]),a._v(" "),_("ol",[_("li",[a._v("浏览器首次访问脚本，将创建全局上下文，并压入栈顶（浏览器关闭前不可弹出），此时进行全局代码的初始化，即进行变量声明和函数声明")]),a._v(" "),_("li",[a._v("全局上下文代码执行时可能会遇到函数，执行函数的时候会创建函数上下文并压入栈顶，然后创建对应的作用域")]),a._v(" "),_("li",[a._v("一旦上下文执行完毕，就会从栈顶弹出，并将上下文控制权交还给当前栈")]),a._v(" "),_("li",[a._v("依次执行，最终回到全局执行上下文")])]),a._v(" "),_("blockquote",[_("p",[a._v("程序执行完毕，则会被弹出栈顶，若无闭包（变量或函数被引用），则这个函数的内存会被垃圾回收器回收")])]),a._v(" "),_("blockquote",[_("p",[a._v("激活其他执行上下文的某执行上下文被称为调用者（caller），被激活的执行上下文被称为被调用者（callee），一个执行上下文即可能是调用者也可能是被调用者\n当一个caller激活了一个callee时，caller会暂停自身执行，将控制权交给callee，此时callee被放进执行上下文栈，被称为进行中的上下文。当这个callee上下文结束后，将控制权交还给它的caller，caller会在刚才暂停的地方继续执行。在这个caller结束后，会继续触发其他的上下文")])]),a._v(" "),_("p",[_("img",{attrs:{src:v(349),alt:"执行上下文栈"}})]),a._v(" "),_("h2",{attrs:{id:"执行上下文"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#执行上下文"}},[a._v("#")]),a._v(" 执行上下文")]),a._v(" "),_("p",[a._v("执行上下文可以理解成代码执行时的环境，是一个抽象概念。当执行一段可执行代码时，都会创建对应的执行上下文\n执行上下文包含三个属性，即变量对象（VO），作用域链和this")]),a._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[a._v("executionContext: {\n  variable object: vars,function, arguments,\n  scope chains: variable objects + all parents scopes,\n  thisValue: context object\n}\n")])])]),_("h3",{attrs:{id:"this"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#this"}},[a._v("#")]),a._v(" this")]),a._v(" "),_("p",[a._v("this是执行上下文的一个属性，值从上下文中获得，取决于进入上下文的情况")]),a._v(" "),_("h3",{attrs:{id:"变量对象vo"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#变量对象vo"}},[a._v("#")]),a._v(" 变量对象VO")]),a._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",[_("code",[a._v("变量对象时执行上下文的一个属性，存放一些变量信息，例如声明的变量、声明的函数，arguments（形参数组）等\n只有全局上下文的变量对象可以通过VO的属性名称间接访问，因为全局上下文中，变量对象就是全局对象，其他上下文不能通过VO的属性名称间接访问变量对象\n")])])]),_("h3",{attrs:{id:"全局对象"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#全局对象"}},[a._v("#")]),a._v(" 全局对象")]),a._v(" "),_("ol",[_("li",[a._v("全局对象在程序初始化的时候创建，这个对象只存在一份，它的属性在程序的任何地方都可以访问，全局对象的生命周期终止于程序退出的那一刻")]),a._v(" "),_("li",[a._v("全局对象创建阶段将Math、String、Date、parseInt等预置属性作为自身属性，同时还可以吧其他对象作为（额外的）属性")]),a._v(" "),_("li",[a._v("在DOM中，可以通过全局对象的window属性来访问全局对象自身")]),a._v(" "),_("li",[a._v("可以通过全局上下文的this来访问全局对象，同样可以递归自身")]),a._v(" "),_("li",[a._v("当访问全局对象的属性时通常会忽略掉前缀，但全局对象不可以通过名称直接访问")]),a._v(" "),_("li",[a._v("全局对象存储着全局范围内定义的变量和函数声明")])]),a._v(" "),_("h3",{attrs:{id:"函数执行流程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#函数执行流程"}},[a._v("#")]),a._v(" 函数执行流程")]),a._v(" "),_("ol",[_("li",[a._v("若有形参，给形参赋值")]),a._v(" "),_("li",[a._v("进行私有（函数）作用域的预解析")]),a._v(" "),_("li",[a._v("私有（函数）作用域的代码自上而下执行")])]),a._v(" "),_("h3",{attrs:{id:"函数的上下文变量对象"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#函数的上下文变量对象"}},[a._v("#")]),a._v(" 函数的上下文变量对象")]),a._v(" "),_("p",[a._v("进入函数的执行上下文时，函数的变量对象（VO）被以下属性填充")]),a._v(" "),_("ol",[_("li",[a._v("形参， 属性名为参数名，值为实参的值，若无传递，则其值为undefined")]),a._v(" "),_("li",[a._v("函数声明，由名称和对应值组成变量对象的属性被创建，若变量对象中已经存在相应值，则只替换")]),a._v(" "),_("li",[a._v("变量声明，通过var声明的，在VO中的值为undefined，若VO中存在相同的属性，则不会影响到已存在的属性")])]),a._v(" "),_("h3",{attrs:{id:"变量对象优先级问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#变量对象优先级问题"}},[a._v("#")]),a._v(" 变量对象优先级问题")]),a._v(" "),_("ol",[_("li",[a._v("变量和函数重名时，函数的优先级高于变量（包括形参）"),_("br"),a._v("\n2.函数声明在var声明之上，优先级高")]),a._v(" "),_("li",[a._v("函数执行时，函数内部才预解析，预解析自上而下，并不包括函数内部代码")]),a._v(" "),_("li",[a._v("预解析时先给实参赋值在进入函数内部")]),a._v(" "),_("li",[a._v("未使用var、let、const 声明的变量都是全局变量")])]),a._v(" "),_("h3",{attrs:{id:"活动对象ao"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#活动对象ao"}},[a._v("#")]),a._v(" 活动对象AO")]),a._v(" "),_("p",[a._v("创建函数上下文阶段，变量对象被创建，但此时变量对象的属性不能被访问。只有当函数执行时，变量对象被激活，变成了活动对象。此时变量对象的属性可以被访问，进入执行阶段的操作。")]),a._v(" "),_("h3",{attrs:{id:"作用域"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#作用域"}},[a._v("#")]),a._v(" 作用域")]),a._v(" "),_("ol",[_("li",[a._v("程序初始化时会形成全局作用域，在此期间声明的变量和函数是全局变量")]),a._v(" "),_("li",[a._v("函数执行时会形成函数作用域，函数作用域里声明的变量和函数属于函数的私有变量，外部不可访问")])]),a._v(" "),_("h3",{attrs:{id:"作用域链"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#作用域链"}},[a._v("#")]),a._v(" 作用域链")]),a._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",[_("code",[a._v("作用域链是执行上下文的一个属性，原理与原型链类似\n作用域链包含当前作用域的变量对象（VO）和所有的父级作用域链\n")])])]),_("h3",{attrs:{id:"在作用域链查找变量"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#在作用域链查找变量"}},[a._v("#")]),a._v(" 在作用域链查找变量")]),a._v(" "),_("ol",[_("li",[a._v("代码执行的时候遇到一个变量foo，首先确定它是否当前作用域里的私有变量，若是则在当前作用域的变量对象（VO）里查找")]),a._v(" "),_("li",[a._v("若不是私有变量，则去它的父级作用域("),_("em",[a._v("parent")]),a._v(")查找")]),a._v(" "),_("li",[a._v("若父级作用域中不存在此变量，则沿着作用域链向上查找")]),a._v(" "),_("li",[a._v("直到全局上下文也没找到则报错")])])])}),[],!1,null,null,null);t.default=s.exports}}]);