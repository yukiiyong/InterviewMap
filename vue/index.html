<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Vue | InterviewMap</title>
    <meta name="generator" content="VuePress 1.5.3">
    
    <meta name="description" content="一些知识点汇总">
    <link rel="preload" href="/InterviewMap/assets/css/0.styles.f8f27b20.css" as="style"><link rel="preload" href="/InterviewMap/assets/js/app.7ef33b20.js" as="script"><link rel="preload" href="/InterviewMap/assets/js/2.c7a96f3a.js" as="script"><link rel="preload" href="/InterviewMap/assets/js/24.fdfbf9f3.js" as="script"><link rel="prefetch" href="/InterviewMap/assets/js/10.0f9db2d8.js"><link rel="prefetch" href="/InterviewMap/assets/js/11.599fcd1d.js"><link rel="prefetch" href="/InterviewMap/assets/js/12.48698b7d.js"><link rel="prefetch" href="/InterviewMap/assets/js/13.0f44793a.js"><link rel="prefetch" href="/InterviewMap/assets/js/14.f6835b44.js"><link rel="prefetch" href="/InterviewMap/assets/js/15.246434a8.js"><link rel="prefetch" href="/InterviewMap/assets/js/16.1bbb01e8.js"><link rel="prefetch" href="/InterviewMap/assets/js/17.fb33cca3.js"><link rel="prefetch" href="/InterviewMap/assets/js/18.38361e45.js"><link rel="prefetch" href="/InterviewMap/assets/js/19.ceedfd89.js"><link rel="prefetch" href="/InterviewMap/assets/js/20.49b80d6a.js"><link rel="prefetch" href="/InterviewMap/assets/js/21.f1aca8c3.js"><link rel="prefetch" href="/InterviewMap/assets/js/22.c985210e.js"><link rel="prefetch" href="/InterviewMap/assets/js/23.9ea95266.js"><link rel="prefetch" href="/InterviewMap/assets/js/25.5b4ed8a5.js"><link rel="prefetch" href="/InterviewMap/assets/js/26.e1c64e30.js"><link rel="prefetch" href="/InterviewMap/assets/js/27.376d4e22.js"><link rel="prefetch" href="/InterviewMap/assets/js/28.73c85acd.js"><link rel="prefetch" href="/InterviewMap/assets/js/29.00c39ca9.js"><link rel="prefetch" href="/InterviewMap/assets/js/3.77ff65da.js"><link rel="prefetch" href="/InterviewMap/assets/js/4.21e61ed5.js"><link rel="prefetch" href="/InterviewMap/assets/js/5.4c15f03b.js"><link rel="prefetch" href="/InterviewMap/assets/js/6.7533068f.js"><link rel="prefetch" href="/InterviewMap/assets/js/7.6c4ade9d.js"><link rel="prefetch" href="/InterviewMap/assets/js/8.24677f8d.js"><link rel="prefetch" href="/InterviewMap/assets/js/9.452aed5a.js">
    <link rel="stylesheet" href="/InterviewMap/assets/css/0.styles.f8f27b20.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/InterviewMap/" class="home-link router-link-active"><!----> <span class="site-name">InterviewMap</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>js</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>css</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>vue</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/InterviewMap/vue/" aria-current="page" class="active sidebar-link">Vue</a></li><li><a href="/InterviewMap/vue/component.html" class="sidebar-link">手动挂载组件</a></li><li><a href="/InterviewMap/vue/loading.html" class="sidebar-link">自定义一个loading组件</a></li><li><a href="/InterviewMap/vue/provide.html" class="sidebar-link">provide/inject</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>git</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>module</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>webpack</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>js</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h4 id="描述vue从初始化页面－修改数据－刷新页面的过程"><a href="#描述vue从初始化页面－修改数据－刷新页面的过程" class="header-anchor">#</a> 描述Vue从初始化页面－修改数据－刷新页面的过程</h4> <p>当Vue进入初始化阶段，一方面Vue会遍历data里的属性，并用Object.defineProperty将其转化为setter和getter，实现数据劫持。另一方面Vue的编译器会对元素节点的各个指令进行解析，初始化视图。并订阅watcher来更新视图，此时将watcher添加到消息订阅器dep中。此时初始化完毕。<br>
new 一个自己的Watcher对象，然后Watcher会立即调用组件的render函数去生成虚拟DOM，此时会触发getter函数，将当前的Watcher函数注册进sub里。
另一方面，当data里的数据发生变化时，会触发Observer中的setter方法，此时会调用Dep.notify方法。Dep会遍历所有的订阅者watcher，并调用其update方法。Vue内部再通过diff算法，patch相应的更新来完成对订阅者视图的改变。</p> <h4 id="vue实现双向绑定原理"><a href="#vue实现双向绑定原理" class="header-anchor">#</a> Vue实现双向绑定原理</h4> <ol><li>实现一个监听器Observer。对数据对象进行遍历，包括子属性对象的属性。通过Object.defineProperty将其转换为getter和setter。这样的话，对这个对象的某个属性进行赋值，就会触发setter就能监听到数据的变化。</li> <li>实现一个编译器compiler。解析模板指令，将模板中的变量替换成数据，然后初始化渲染视图。然后对指令对应的节点绑定更新函数，添加监听数据的订阅者。一旦数据有变动，收到通知，调用更新函数来进行更新。</li> <li>实现一个订阅者Watcher。 Watcher是Observer和Compiler中的桥梁。主要任务是当Observer中属性发生变化时，当收到属性变化的消息时，触发Watcher中的更新函数来进行更新。</li> <li>实现一个订阅器Dep。采用发布－订阅模式，用来收集订阅者Watcher。对监听器Observer和Watcher进行统一管理。</li></ol> <h4 id="vue实现单向数据流"><a href="#vue实现单向数据流" class="header-anchor">#</a> Vue实现单向数据流</h4> <p>所有的prop都使得其父子prop之间形成一个单向的下行绑定。父级prop的更新会向下流动到子组件，但是反过来不行。这是为了防止子组件意外改变父组件的状态，从而使应用数据流难以理解。<br>
额外的，每次父组件更新时，子组件的prop都会刷新成最新的值。这意味着我们不应该在子组件中修改prop。如果你这么做了，Vue会在浏览器控制台发出一个警告。子组件想修改prop，只能通过＄emit向父组件派发一个事件。父组件收到后，由父组件修改。</p> <h4 id="两种试图修改prop值情形"><a href="#两种试图修改prop值情形" class="header-anchor">#</a> 两种试图修改prop值情形</h4> <ol><li>这个prop用来传递一个初始值，子组件希望将其作为一个本地prop数据进行使用（定义一个本地的data属性并将此prop用作其原始值</li> <li>这个prop以一个原始值传入并需要转换（使用这个prop值来作为计算属性的依赖）</li></ol> <h4 id="vue中key值作用"><a href="#vue中key值作用" class="header-anchor">#</a> Vue中key值作用</h4> <p>vue中key值作为vnode的唯一标记。通过这个标记，我们在进行diff操作时可以更准确、更快速。<br>
使用for来更新已经渲染的列表时，如果没有key值，就会采用就地复用策略。即当列表数据修改时，会根据key值来判断列表中某个元素是否修改。如果有，则重新渲染这一项。否则服用之前的DOM，仅修改value值。</p> <h4 id="响应式原理-react-与-vue差别"><a href="#响应式原理-react-与-vue差别" class="header-anchor">#</a> 响应式原理 REACT 与 Vue差别</h4> <p>响应式原理意味着在数据改变时，视图也随之更新，意味着我们在开发过程中只需要进行数据的管理。<br>
React也有这种特性，React通过this.setState来改变数据，然后通过新数据生成新的虚拟DOM，最后通过新旧虚拟DOM对比找出需要更新的节点，也就是说，React通过虚拟DOM和DOM diff算法做到响应式。<br>
而Vue则是利用Object.defineProperty方法里的setter和getter方法的观察者模式来实现。</p> <h4 id="vue-set原理"><a href="#vue-set原理" class="header-anchor">#</a> Vue.$set原理</h4> <ol><li>挂在prototype上（初始化时）</li> <li>若target为数组，使用splice来进行强制更新</li> <li>若target为普通对象，直接赋值</li> <li>若target 为Vue实例或根数据列表，报错</li> <li>若target为响应式对象，赋值后手动Observe</li></ol> <h4 id="使用vuex-只需要执行vue-use-vuex-，并在vue的配置中传入一个store对象的实例，store如何实现注入"><a href="#使用vuex-只需要执行vue-use-vuex-，并在vue的配置中传入一个store对象的实例，store如何实现注入" class="header-anchor">#</a> 使用Vuex 只需要执行Vue.use(vuex)，并在Vue的配置中传入一个store对象的实例，store如何实现注入</h4> <p><code>Vue.use(vuex)</code>方法执行的是install，它实现了Vue实例对象的init方法的封装与注入，使传入的store对象，被设置到Vue上下文环境的$store中，因此Vue Component在任意地方都能通过$store访问到store</p> <blockquote><p>Vue.js Vue实现响应式并不是在数据变化后进行DOM更新，而是按一定策略进行更新</p></blockquote> <p><strong>$nextTick</strong> 是下次DOM更新循环结束之后执行延迟回调，在数据修改之后执行$nextTick，则可以在回调函数中获取更新后的DOM</p> <p><strong>计算属性computed</strong> 相关依赖发生变化时才调用，依赖于return的数据。计算属性是基于他们的依赖进行缓存的，默认只有getter，也可以有setter</p> <p><strong>watch（侦听器）</strong> 名字变化（数据）即调用，用于数据变化时执行异步或开销较大的操作<br> <strong>赋值</strong>不可以在Vue实例中直接定义属性，需在data中初始化属性或调用vm.$set定义</p> <h4 id="插值语法"><a href="#插值语法" class="header-anchor">#</a> 插值语法</h4> <ol><li>文本插值：数据绑定用</li> <li>html插值 使用v-html指令输出html代码</li> <li>属性绑定 使用v-bind指令，如<code>v-bind:class=”{‘className’=Boolean}”</code></li></ol> <p><strong>指令</strong> 带有v-前缀的特殊属性，如<code>v-if</code>，<code>v-bind</code><br> <strong>参数</strong> 在指令后用冒号：指明，如 <code>v-bind:src=http://baidu.com</code> <strong>表达式</strong> Vue支持JavaScript表达式，但只能包含单个表达式</p> <h4 id="修饰符"><a href="#修饰符" class="header-anchor">#</a> 修饰符</h4> <ol><li>以半角句号.指明的特殊后缀，用于指出一个指令应该以特殊方式绑定 <code>v-on:click= func</code>（事件绑定）</li> <li>事件修饰符有.stop .prevent .capture(事件捕获模式) .self(自身触发) .once .passive(默认行为立即触发)</li> <li>事件修饰符可以链式调用，但需要注意顺序，如<code>@click.prevent.self</code>（阻止所有点击），<code>@click.self.prevent</code>(阻止自身点击)</li> <li>按键修饰符 通过调用按键keycode来进行修饰，同时vue提供了13种常用按键的别名，如enter,tab,left,right,up,down,shift,ctrl,delete,esc,space,alt,meta(.exact 精确控制按键)，如<code>@keyup.enter=”submit”</code></li></ol> <p><strong>过滤器</strong> 过滤器采用管道符号|，过滤器本质是一个函数，如</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">{</span><span class="token punctuation">{</span>data <span class="token operator">|</span> <span class="token function">filter</span><span class="token punctuation">(</span>arguments<span class="token punctuation">}</span><span class="token punctuation">}</span>
<span class="token operator">&lt;</span>div v<span class="token operator">-</span>bind<span class="token operator">:</span>id<span class="token operator">=</span>”idData <span class="token operator">|</span> filter”<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>  
</code></pre></div><p><strong>缩写</strong> <code>v-bind:src</code> 可以缩写成 <code>:src</code>，<code>v-on:click</code> 可以缩写成 <code>@click</code> <strong>构造器</strong> 每个vue应用都是通过构造函数<code>Vue()</code> 来创建一个vue的根实例来启动的<br> <strong>属性与方法</strong> 每个vue实例都会代理data对象里所有的属性（双向数据绑定），同时也拥有实例的属性和方法，这些实例的属性，方法用$与data对象的属性和方法区分</p> <h4 id="条件渲染"><a href="#条件渲染" class="header-anchor">#</a> 条件渲染</h4> <ol><li>v-for优先级大于v-if（v-if可在外层调用）</li> <li>v-for可用于渲染一个数组，<code>v-for=”item in items”</code>也可用于一个对象的属性，使用key标唯一</li></ol> <p><strong>就地复用</strong> Vue在数据项的顺序改变时将不会移动DOM元素来匹配数据项的顺序，而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素<br> <strong>观察数组变异方法（改变数组）</strong>：push,pop,shift,unshift,sort,reverse,splice（触发视图更新）<br> <strong>非变异方法</strong>：filter，concat，slice</p> <h4 id="html监听事件-使用v-on好处"><a href="#html监听事件-使用v-on好处" class="header-anchor">#</a> HTML监听事件(使用v-on好处)</h4> <ol><li>HTML可以精确定位JavaScript对应方法</li> <li>viewmodel代码是纯粹的逻辑和DOM解耦，易于测试</li> <li>viewmodel被销毁时，事件处理器自动删除</li> <li>v-model 在表单元素上创建双向数据绑定，它会根据控件类型自动选择正确的方法来更新元素。v-model实质上是负责监听用户输入以更新数据</li></ol> <p><strong>文本</strong> <code>&lt;input v-model=&quot;shuru&quot;&gt;</code> //shuru值改变影响别处调用<br> <strong>多行文本</strong> 多行文本在文本区域插值并不会生效，应用<code>v-model</code>代替</p> <h4 id="复选框-单个勾选框，逻辑值"><a href="#复选框-单个勾选框，逻辑值" class="header-anchor">#</a> 复选框 单个勾选框，逻辑值</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">&quot;checkbox&quot;</span> id<span class="token operator">=</span><span class="token string">&quot;checkbox&quot;</span> v<span class="token operator">-</span>model<span class="token operator">=</span><span class="token string">&quot;checked&quot;</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>label <span class="token keyword">for</span><span class="token operator">=</span><span class="token string">&quot;checkbox&quot;</span><span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">{</span> checked <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>label<span class="token operator">&gt;</span><span class="token comment">//选中哪些就显示哪些</span>
</code></pre></div><p><strong>单选按钮和选择列表</strong> v-model和value绑定，<code>v-model</code>指定变量名称，选中哪一个变量值就为哪一个<br> <strong>值绑定</strong> 对于单选按钮，勾选框和选择列表，<code>v-model</code>绑定的value通常为静态字符串，若想绑定value到Vue实例的动态属性上，可以使用<code>v-bind</code>
复选框:</p> <div class="language-js extra-class"><pre class="language-js"><code>    <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">&quot;checkbox&quot;</span> v<span class="token operator">-</span>model<span class="token operator">=</span><span class="token string">&quot;toggle&quot;</span>  v<span class="token operator">-</span>bind<span class="token operator">:</span><span class="token boolean">true</span><span class="token operator">-</span>value<span class="token operator">=</span><span class="token string">&quot;a&quot;</span> v<span class="token operator">-</span>bind<span class="token operator">:</span><span class="token boolean">false</span><span class="token operator">-</span>value<span class="token operator">=</span><span class="token string">&quot;b&quot;</span><span class="token operator">&gt;</span>
    vm<span class="token punctuation">.</span>toggle <span class="token operator">===</span> vm<span class="token punctuation">.</span>a  <span class="token comment">// 当选中时</span>
    vm<span class="token punctuation">.</span>toggle <span class="token operator">===</span> vm<span class="token punctuation">.</span>b   <span class="token comment">// 当没有选中时</span>
</code></pre></div><p>单选按钮:</p> <div class="language-js extra-class"><pre class="language-js"><code>    <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">&quot;radio&quot;</span> v<span class="token operator">-</span>model<span class="token operator">=</span><span class="token string">&quot;pick&quot;</span> v<span class="token operator">-</span>bind<span class="token operator">:</span>value<span class="token operator">=</span><span class="token string">&quot;a&quot;</span><span class="token operator">&gt;</span>
    vm<span class="token punctuation">.</span>pick <span class="token operator">===</span> vm<span class="token punctuation">.</span>a   <span class="token comment">// 当选中时</span>
</code></pre></div><p>选择列表的选项:</p> <div class="language-js extra-class"><pre class="language-js"><code>    <span class="token operator">&lt;</span>select v<span class="token operator">-</span>model<span class="token operator">=</span><span class="token string">&quot;selected&quot;</span><span class="token operator">&gt;</span>
     <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 内联对象字面量 <span class="token operator">--</span><span class="token operator">&gt;</span>
     <span class="token operator">&lt;</span>option v<span class="token operator">-</span>bind<span class="token operator">:</span>value<span class="token operator">=</span><span class="token string">&quot;{ number: 123 }&quot;</span><span class="token operator">&gt;</span><span class="token number">123</span><span class="token operator">&lt;</span><span class="token operator">/</span>option<span class="token operator">&gt;</span>
   <span class="token operator">&lt;</span><span class="token operator">/</span>select<span class="token operator">&gt;</span>
    <span class="token comment">// 当选中时</span>
    <span class="token keyword">typeof</span> vm<span class="token punctuation">.</span>selected <span class="token comment">// =&gt; 'object'</span>
    vm<span class="token punctuation">.</span>selected<span class="token punctuation">.</span>number <span class="token comment">// =&gt; 123</span>
</code></pre></div><h4 id="v-model修饰符"><a href="#v-model修饰符" class="header-anchor">#</a> v-model修饰符</h4> <ol><li>.lazy 在change而不是input事件更新</li> <li>.number 将用户输入的值变为Number类型</li> <li>.trim 用户输入的值过滤首尾空格</li></ol> <h4 id="组件"><a href="#组件" class="header-anchor">#</a> 组件</h4> <ul><li>组件是Vue.js最强大的功能之一。组件可以拓展HTML元素，封装可重用代码。在较高层次上，组件是自定义元素，Vue.js编译器为组件提供特殊功能</li></ul> <h4 id="全局注册组件"><a href="#全局注册组件" class="header-anchor">#</a> 全局注册组件</h4> <p><code>Vue.component(‘my-component’, {//选项})</code></p> <ul><li>注册之后可以作为自定义元素<code>&lt;my-component&gt;</code>在任何新创建的Vue根实例中模板中使用，注意必须确保在初始化根实例之前注册组件</li> <li><strong>全局注册缺点</strong> 不再使用组件，但组件仍包含在构建结果中，JS文件增加</li> <li><strong>局部注册组件</strong>  通过Vue实例的实例选项components注册仅在其作用域中可用的组件<br> <code>components：{‘cname’， cname}</code></li> <li>局部注册缺点 局部注册的组件在其子组件及外部不可以</li></ul> <h4 id="dom模板解析注意事项"><a href="#dom模板解析注意事项" class="header-anchor">#</a> DOM模板解析注意事项</h4> <ul><li>当把DOM作为模板时，会受到HTML本身的一些限制，因为Vue只有在浏览器解析、规范化模板之后才能获取其内容。</li> <li>像ul，ol，table，select这样的元素里包含的元素有限制，在自定义组件中使用这些受限制的元素会导致一些问题，会把自定义组件当成无效内容</li> <li>若使用字符串模板则无以上问题，如</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>script type<span class="token operator">=</span>”text<span class="token operator">/</span>x<span class="token operator">-</span>template”<span class="token operator">&gt;</span> JavaScript内联字符串模板 <span class="token punctuation">.</span>vue组件  
</code></pre></div><p><strong>data必须是函数原因</strong> data不是函数，Vue会停止运行，并在控制台发出警告，告诉你组件实例中data必须是一个函数</p> <h4 id="prop"><a href="#prop" class="header-anchor">#</a> prop</h4> <ul><li>组件实例的作用域是孤立的，意味着不能再子组件模板内直接引用父组件的数据</li> <li>prop特性在HTML上使用短横线，在JS上使用驼峰<br> <strong>静态prop</strong></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>blog title<span class="token operator">=</span>”a”<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>blog<span class="token operator">&gt;</span>
</code></pre></div><p>静态prop传递字符串<br> <strong>动态prop</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>blog <span class="token operator">:</span>title<span class="token operator">=</span>”a”<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>blog<span class="token operator">&gt;</span>
</code></pre></div><p>动态prop可以传递非字符串</p> <h4 id="单向数据流"><a href="#单向数据流" class="header-anchor">#</a> 单向数据流</h4> <blockquote><p>父组件的prop更新会传递到子组件，父组件刷新时，子组件的所有prop将刷新成最新的值</p></blockquote> <ol><li>试图改变子prop</li> <li>prop用来传递初始值，定义一个本地data属性将prop用作初始值</li></ol> <ul><li><p>定义一个计算属性，处理prop值并返回<br> <strong>prop验证</strong>  可以为组件的prop定义验证规则，传入的数据不符合要求，Vue会发出警告。要指定验证规则，需要<strong>用对象的形式定义prop</strong>，不能用字符串数组</p></li> <li><p><strong>type</strong>：原生构造函数之一 Function,String,Number,Boolean,Array,Object,Symbol</p></li> <li><p><strong>default</strong> 默认值</p></li> <li><p><strong>required</strong> true/false</p></li> <li><p><strong>validator</strong> function</p></li></ul> <h4 id="自定义事件"><a href="#自定义事件" class="header-anchor">#</a> 自定义事件</h4> <ol><li>自定义事件名使用kebab-case</li> <li>一个组件上的v-model会默认利用名为value的prop和名为input的事件，可以在组件定义时利用model选项指定</li> <li>在根元素监听子元素的元素事件<code>v-on:focus.native=”focusEv”</code></li> <li>$listeners 包含作用在此组件的所有监听器。可以在子元素使用<code>v-on=”$listeners”</code></li> <li>子prop向父组件更新（.sync） 拓展为一个自动更新父组件属性的v-on监听器</li></ol> <h4 id="插槽（slot）"><a href="#插槽（slot）" class="header-anchor">#</a> 插槽（slot）</h4> <blockquote><p>分发内容，混合父组件内容与子组件自己的模板</p></blockquote> <ol><li>单个插槽（默认） 组件定义时无<code>&lt;slot&gt;</code>，传入组件的数据（使用时）会被抛弃，默认</li> <li>具名插槽 定义<code>&lt;slot name=”header”&gt;&lt;/slot&gt;</code></li> <li>使用（父组件使用slot）<code>&lt;template slot=”header”&gt;&lt;/template&gt;</code></li> <li>插槽默认内容 定义在slot里面的内容 <code>&lt;slot&gt;默认内容&lt;/slot&gt;</code></li></ol> <h4 id="编译作用域"><a href="#编译作用域" class="header-anchor">#</a> 编译作用域</h4> <ol><li>父模板所有东西都在父级作用域编译</li> <li>子组件模板所有东西都在子组件作用域编译</li></ol> <h4 id="watch-computed-filters"><a href="#watch-computed-filters" class="header-anchor">#</a> watch/computed/filters</h4> <ul><li>watch监控已有属性，一旦属性发生改变就回去调用对应的方法</li> <li>computed监控已有属性，一旦属性的依赖发生改变就会调用对应的方法，返回一个新的属性（响应式）</li> <li>filters为我们提供一个方法，用来帮我们对数据进行筛选</li></ul> <h4 id="computed与filters区别"><a href="#computed与filters区别" class="header-anchor">#</a> computed与filters区别</h4> <ol><li>触发时机<br>
computed属性的更新依赖于Vue的数据更新通知机制，在属性所依赖的其他数据项发生改变时才会重新出发计算。优点是计算频率比较低，缺点是难以抽取独立逻辑，依赖于组件，复用性比较低<br>
filters只在显式调用时触发，常用于模板渲染上，优点是易于在组件外抽象，缺点是每次模板重新渲染都要计算一次</li> <li>应用范围不一样<br>
computed可以应用于其他computed，生命周期函数，methods，模板<br>
filter一般用于模板渲染，若要在其他位置使用，则需使用this._f函数<br>
filters支持链式调用</li> <li>定义方式
computed 只能在组件内部或者是mixin对象中定义<br>
filters 只能通过组件内部的filters属性定义，或者在组件外部通过Vue.filter函数定义</li> <li>应用场景<br>
fiter无法缓存，调用频率高，适用于格式化输出场景<br>
computed具有缓存能力，在组件内普适性较高，适用于复杂数据转换、统计等功能、</li></ol> <h4 id="作用域插槽"><a href="#作用域插槽" class="header-anchor">#</a> 作用域插槽</h4> <ol><li>是一种特殊类型的插槽，用作一个（能被传递数据的）可重用模板，来代替已渲染的组件</li> <li>在子组件，只需将数据传递到插槽，就像prop传递到组件一样</li></ol> <blockquote><p>若一个JS表达式在一个函数定义的参数位置有效，那么此表达式实际上可以被slot-scope接受</p></blockquote> <p><strong>动态组件</strong> 通过保留的component元素，动态的绑定到它的is特性，我们可以让多个组件使用同一个挂载点，并动态切换</p> <ol><li>keep-alive 将切换出去的组件缓存起来，避免重新渲染</li> <li>vue2.1.0后，keep-alive加入include（包含的组件缓存），exclude（排除的组件缓存，优先级大于include）</li> <li>keep-alive中可以是字符串（不需要v-bind），数组，正则表达式（需v-bind），分隔用逗号</li></ol> <h4 id="边界情况"><a href="#边界情况" class="header-anchor">#</a> 边界情况</h4> <ol><li>访问根实例（new Vue 实例 的子组件）<code>$root</code></li> <li>从子组件访问父组件 <code>$parent</code></li> <li>访问子组件实例或子元素<code>ref / $refs</code></li></ol> <h4 id="程序化事件监听"><a href="#程序化事件监听" class="header-anchor">#</a> 程序化事件监听</h4> <p>1.<code>$on(eventName, eventHandler)</code><br>
2.<code>$once(eventName, eventHandler)</code><br>
3.<code>$off(eventName, eventHandler)</code></p> <p><strong>递归调用</strong> 条件性调用，组件必须有name选项
循环引用<br>
Vue.component注册<br>
本地注册组件时，webpack异步import<br>
v-once 根元素上添加以确保内容只计算一次后缓存（低开销的静态组件使用）<br>
$forceUpdate 强制更新</p> <h4 id="vue组件间传递数据"><a href="#vue组件间传递数据" class="header-anchor">#</a> Vue组件间传递数据</h4> <p>1.父子组件 父组件通过prop传递数据到子组件，子组件通过显式派发update事件传递数据到父组件（.sync）</p> <ul><li>父组件通过v-on监听子组件数据更新事件的派发，子组件主动派发数据更新事件（emit）</li> <li>v-model</li></ul> <ol start="2"><li>非父子组件 EventHub（桥）、provide/inject 、vuex</li></ol> <h4 id="过渡效果"><a href="#过渡效果" class="header-anchor">#</a> 过渡效果</h4> <blockquote><p>Vue在插入（enter）和移除（leave）DOM时应用</p></blockquote> <ul><li>包括以下工具：</li></ul> <ol><li>在 CSS 过渡和动画中自动应用 class</li> <li>可以配合使用第三方 CSS 动画库，如 Animate.css</li> <li>在过渡钩子函数中使用 JavaScript 直接操作 DOM</li> <li>可以配合使用第三方 JavaScript 动画库，如 Velocity.js</li></ol> <ul><li><strong>单元素/组件的过渡：</strong><br>
Vue 提供了 transition 的封装组件，在<strong>下列情形</strong>中，可以给任何元素和组件添加 entering/leaving 过渡</li> <li>条件渲染 (使用 v-if)</li> <li>条件展示 (使用 v-show)</li> <li>动态组件 <code>&lt;component is=&quot;&quot;&gt;</code></li> <li>组件根节点</li></ul> <p>当插入或删除包含在 transition 组件中的元素时，Vue 将会做以下处理：</p> <ul><li>自动嗅探目标元素是否应用了 CSS 过渡或动画，如果是，在恰当的时机添加/删除 CSS 类名。</li> <li>如果过渡组件提供了 JavaScript 钩子函数，这些钩子函数将在恰当的时机被调用。</li> <li>如果没有找到 JavaScript 钩子并且也没有检测到 CSS 过渡/动画，DOM 操作 (插入/删除) 在下一帧中立即执行。</li> <li><strong>过渡的类名：</strong> <blockquote><p>在进入/离开的过渡中，会有 6 个 class 切换。</p></blockquote> <ol><li>v-enter：定义进入过渡的开始状态。在元素被插入时生效，在下一个帧移除。</li> <li>v-enter-active：定义过渡的状态。在元素整个过渡过程中作用，在元素被插入时生效，在 transition/animation 完成之后移除。这个类可以被用来定义过渡的过程时间，延迟和曲线函数。</li> <li>v-enter-to: 2.1.8版及以上 定义进入过渡的结束状态。在元素被插入一帧后生效 (于此同时 v-enter 被删除)，在 transition/animation 完成之后移除。</li> <li>v-leave: 定义离开过渡的开始状态。在离开过渡被触发时生效，在下一个帧移除。</li> <li>v-leave-active：定义过渡的状态。在元素整个过渡过程中作用，在离开过渡被触发后立即生效，在 transition/animation 完成之后移除。这个类可以被用来定义过渡的过程时间，延迟和曲线函数。</li> <li>v-leave-to: 2.1.8版及以上 定义离开过渡的结束状态。在离开过渡被触发一帧后生效 (于此同时 v-leave 被删除)，在 transition/animation 完成之后移除。</li></ol></li></ul> <h6 id="自己实践之后的感悟："><a href="#自己实践之后的感悟：" class="header-anchor">#</a> 自己实践之后的感悟：</h6> <ul><li>在定义离开过渡的时候，最后就只定义class-leave-active的类，class-leave效果不明显。</li> <li>CSS的过渡，就用transition：属性 过渡时间 速度 整个动画时间</li> <li>动画的过渡，就用animation：动画名 过渡时间</li></ul> <h4 id="css-动画："><a href="#css-动画：" class="header-anchor">#</a> CSS 动画：</h4> <p>CSS 动画用法同 CSS 过渡，区别是在动画中 v-enter 类名在节点插入 DOM 后不会立即删除，而是在 animationend 事件触发时删除。</p> <h4 id="自定义过渡的类名："><a href="#自定义过渡的类名：" class="header-anchor">#</a> 自定义过渡的类名：</h4> <blockquote><p>我们可以通过以下特性来自定义过渡类名：</p></blockquote> <p>enter-class<br>
enter-active-class<br>
enter-to-class (2.1.8+)<br>
leave-class<br>
leave-active-class<br>
leave-to-class (2.1.8+)<br>
他们的优先级高于普通的类名，这对于 Vue 的过渡系统和其他第三方 CSS 动画库，如 Animate.css 结合使用十分有用。</p> <h4 id="同时使用过渡和动画"><a href="#同时使用过渡和动画" class="header-anchor">#</a> 同时使用过渡和动画:</h4> <p>Vue 为了知道过渡的完成，必须设置相应的事件监听器。它可以是 transitionend 或 animationend ，这取决于给元素应用的 CSS 规则。如果你使用其中任何一种，Vue 能自动识别类型并设置监听。<br>
你需要给同一个元素同时设置两种过渡动效，比如 animation 很快的被触发并完成了，而 transition 效果还没结束。在这种情况中，你就需要使用 type 特性并设置 animation 或 transition 来明确声明你需要 Vue 监听的类型。</p> <h4 id="显性的过渡持续时间"><a href="#显性的过渡持续时间" class="header-anchor">#</a> 显性的过渡持续时间</h4> <blockquote><p>在很多情况下，Vue 可以自动得出过渡效果的完成时机。默认情况下，Vue 会等待其在过渡效果的根元素的第一个 transitionend 或 animationend 事件。</p></blockquote> <p>在这种情况下你可以用 <code>&lt;transition&gt;</code> 组件上的 duration 属性<strong>定制</strong>一个<strong>显性的过渡持续时间 (以毫秒计)</strong>：
<code>&lt;transition :duration=&quot;1000&quot;&gt;...&lt;/transition&gt;</code>
你也可以<strong>定制进入和移出的持续时间</strong>：<br> <code>&lt;transition :duration=&quot;{ enter: 500, leave: 800 }&quot;&gt;...&lt;/transition&gt;</code></p> <h4 id="javascript-钩子"><a href="#javascript-钩子" class="header-anchor">#</a> JavaScript 钩子</h4> <blockquote><p>是一种事件劫持机制，也就是说它会比你的事件更早进行执行处理。</p></blockquote> <p>注意：当只用 JavaScript 过渡的时候， 在 enter 和 leave 中，<strong>回调函数 done 是必须的 。否则，它们会被同步调用，过渡会立即完成</strong>。<br>
推荐对于仅使用 JavaScript 过渡的元素添加 <code>v-bind:css=&quot;false&quot;</code>，<strong>Vue 会跳过 CSS 的检测</strong>。这也可以避免过渡过程中 CSS 的影响。</p> <p><code>&lt;transition v-on:before-enter=&quot;beforeEnter&quot; v-on:enter=&quot;enter&quot; v-on:after-enter=&quot;afterEnter&quot; v-on:enter-cancelled=&quot;enterCancelled&quot; v-on:before-leave=&quot;beforeLeave&quot; v-on:leave=&quot;leave&quot; v-on:after-leave=&quot;afterLeave&quot; v-on:leave-cancelled=&quot;leaveCancelled&quot;&gt;…&lt;/transition&gt;</code><br> <strong>在methods中添加以下方法</strong>：beforeEnter enter afterEnter enterCancelled beforeLeave leave afterLeave leave-cancelled,它们的参数都是el,done（回调函数）</p> <h4 id="初始渲染的过渡"><a href="#初始渲染的过渡" class="header-anchor">#</a> 初始渲染的过渡</h4> <blockquote><p>可以通过 appear 特性设置节点的在初始渲染的过渡，默认和进入和离开过渡一样，同样也可以自定义 CSS 类名。</p></blockquote> <p><code>&lt;transition appear appear-class=&quot;custom-appear-class&quot; appear-to-class=&quot;custom-appear-to-class&quot; (2.1.8+) appear-active-class=&quot;custom-appear-active-class&quot;&gt;&lt;/transition&gt;</code></p> <h4 id="多个元素的过渡"><a href="#多个元素的过渡" class="header-anchor">#</a> 多个元素的过渡:</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>transition name<span class="token operator">=</span><span class="token string">&quot;fade&quot;</span> mode<span class="token operator">=</span><span class="token string">&quot;out-in&quot;</span> <span class="token operator">&gt;</span> <span class="token comment">//name为要使用的css样式名，mode为过渡模式   </span>
  <span class="token operator">&lt;</span>button v<span class="token operator">-</span><span class="token keyword">if</span><span class="token operator">=</span><span class="token string">&quot;flag&quot;</span> key<span class="token operator">=</span><span class="token string">&quot;save&quot;</span> @click<span class="token operator">=</span><span class="token string">&quot;flag=!flag&quot;</span><span class="token operator">&gt;</span>save<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>  
  <span class="token operator">&lt;</span>button v<span class="token operator">-</span><span class="token keyword">else</span> key<span class="token operator">=</span><span class="token string">&quot;edit&quot;</span><span class="token operator">&gt;</span>edit<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>  
<span class="token operator">&lt;</span><span class="token operator">/</span>transition<span class="token operator">&gt;</span>
</code></pre></div><p>//因为切换的是同一个类型的元素，且用到了v-if和v-else。所以都需要加上key，来区别</p> <h4 id="过渡模式："><a href="#过渡模式：" class="header-anchor">#</a> 过渡模式：</h4> <blockquote><p>同时生效的进入和离开的过渡不能满足所有要求，所以 Vue 提供了 过渡模式</p></blockquote> <ul><li>in-out：新元素先过渡，最后在将旧元素过渡出去；</li> <li>out-in：旧元素先过渡出去，在过渡新元素；</li></ul> <h4 id="多个组件的过渡"><a href="#多个组件的过渡" class="header-anchor">#</a> 多个组件的过渡</h4> <blockquote><p>使用条件渲染，用key区分同一类型组件</p></blockquote> <h4 id="列表过渡："><a href="#列表过渡：" class="header-anchor">#</a> 列表过渡：</h4> <ul><li>不同于 <code>&lt;transition&gt;</code>，它会以一个真实元素呈现：默认为一个 <code>&lt;span&gt;</code>。你也可以通过 tag 特性更换为其他元素。</li> <li>内部元素 总是需要 提供唯一的 key 属性值</li></ul> <h4 id="列表的排序过渡："><a href="#列表的排序过渡：" class="header-anchor">#</a> 列表的排序过渡：</h4> <p>需要注意的是使用 FLIP 过渡的元素不能设置为 display: inline 。作为替代方案，可以设置为 display: inline-block 或者放置于 flex 中</p> <h4 id="可复用的过渡："><a href="#可复用的过渡：" class="header-anchor">#</a> 可复用的过渡：</h4> <p>过渡可以通过 Vue 的组件系统实现复用。要创建一个可复用过渡组件，你需要做的就是将<code>&lt;transition&gt;</code> 或者 <code>&lt;transition-group&gt;</code> 作为根组件，然后将任何子组件放置在其中就可以了。</p> <h4 id="动态过渡："><a href="#动态过渡：" class="header-anchor">#</a> 动态过渡：</h4> <p>在 Vue 中即使是过渡也是数据驱动的！动态过渡最基本的例子是通过 name 特性来绑定动态值。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>transition v<span class="token operator">-</span>bind<span class="token operator">:</span>name<span class="token operator">=</span><span class="token string">&quot;transitionName&quot;</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> <span class="token operator">...</span> <span class="token operator">--</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>transition<span class="token operator">&gt;</span>
</code></pre></div><h4 id="混合（mixin）"><a href="#混合（mixin）" class="header-anchor">#</a> 混合（mixin）</h4> <ul><li>是一种分发Vue组件可复用功能的非常灵活的方式。混合对象可以包含任意选项属性。</li> <li>所以组件使用混合对象的时候，所有混合对象的选项可以并入组件本身。</li></ul> <h4 id="mixin选项合并"><a href="#mixin选项合并" class="header-anchor">#</a> mixin选项合并</h4> <blockquote><p>当组件和混合对象含有同名选项的时候，这些选项将以恰当的方式进行混合</p></blockquote> <ol><li>值为对象的选项，例如methods，components，directive，将被混合成同一个对象</li> <li>混合对象的钩子将在组件自身钩子之前调用</li></ol> <h4 id="vue-extend-也使用同样的策略进行合并"><a href="#vue-extend-也使用同样的策略进行合并" class="header-anchor">#</a> Vue.extend()也使用同样的策略进行合并</h4> <ol><li>全局混合 也可以全局注册混合对象。注意，一旦使用全局混合对象，将会影响到所以之后创建的Vue实例。<br>
使用恰当时，可以为自定义对象注入处理逻辑（大多数情况下，只应当应用于自定义选项，也可以作为plugin以避免产生重复应用）</li> <li>自定义选项合并策略 将使用默认策略，即简单的覆盖已有值。若想让自定义选项以自定义逻辑合并，可以向Vue.config.optionMergeStrategies添加一个函数。</li></ol> <h4 id="自定义指令"><a href="#自定义指令" class="header-anchor">#</a> 自定义指令</h4> <blockquote><p>钩子函数 提供如下几个可选的钩子函数</p></blockquote> <ol><li>bind:只调用一次，指令第一次绑定到元素时调用，在这里可以进行一次性的初始化设置</li> <li>inserted：被绑定元素插入父节点时调用（仅保证父节点存在，但不一定已被插入文档中）</li> <li>update：所在组件的VNode更新时调用，但是可能发生在其子VNode更新之前，指令的值可能已经更新，可能未更新，可以通过比较更新前后的值来忽略不必要的模板更新</li> <li>componentUpdated：指令所在组件VNode及其子VNode全部更新后调用</li> <li>unbind：只调用一次，指令与元素解绑时调用</li></ol> <h4 id="自定义指令-钩子函数参数"><a href="#自定义指令-钩子函数参数" class="header-anchor">#</a> 自定义指令 钩子函数参数</h4> <ul><li>el：指令所绑定的元素，可以用来直接操作DOM</li> <li>binding： 一个对象，包含以下属性</li> <li>name:指令名，不包含v-前缀</li> <li>value：指令的绑定值，例如：<code>v-my-directive=”1+1”</code>，绑定值为2</li> <li>oldValue：指令绑定前一个值，仅在update和componentUpdated钩子可用</li> <li>expression：字符串形式的指令表达式。例如<code>v-my-directive=”1+1”</code>中，表达式为”1+1”</li> <li>arg:传给指令的参数，可选。例如<code>v-my-directive：foo</code>中，参数为foo</li> <li>modifiers：一个包含修饰符的对象，例如：<code>v-my-directive.foo.bar</code>中，修饰符对象为<code>{foo:true,bar:true}</code></li> <li>vnode: Vue编译生成的虚拟节点</li> <li>oldvnode：上一个虚拟节点，仅在update和componentUpdated钩子中可用</li></ul> <blockquote><p>注意：除了el以外，其他参数都应该是只读的，切勿修改。若要在钩子之间共享数据，建议通过元素的dataset来进行。</p></blockquote> <h4 id="自定义指令-对象字面量"><a href="#自定义指令-对象字面量" class="header-anchor">#</a> 自定义指令 对象字面量</h4> <blockquote><p>如果指令需要多个值，可以传入一个JavaScript对象字面量。记住，指令函数可以接受所有合法的JavaScript表达式。</p></blockquote> <h4 id="渲染函数-jsx"><a href="#渲染函数-jsx" class="header-anchor">#</a> 渲染函数 &amp; JSX</h4> <ol><li><p>基础：Vue 推荐在绝大多数情况下使用 template 来创建你的 HTML。然而在一些场景中，你真的需要 JavaScript 的完全编程的能力，这就是 render 函数，它比 template 更接近编译器。</p></li> <li><p>节点、树以及虚拟 DOM:<br>
每个元素都是一个节点。每片文字也是一个节点。<br>
甚至注释也都是节点。一个节点就是页面的一个部分。<br>
就像家谱树一样，每个节点都可以有孩子节点<br>
2.1. 虚拟 DOM: Vue 通过建立一个虚拟 DOM 对真实 DOM 发生的变化保持追踪。<br>
createElement 返回的不是一个实际的 DOM 元素。它更准确的名字可能是 createNodeDescription，因为它所包含的信息会告诉 Vue 页面上需要渲染什么样的节点，及其子节点。我们把这样的节点描述为“虚拟节点 (Virtual Node)”，也常简写它为“VNode”。“虚拟 DOM”是我们对由 Vue 组件树建立起来的整个 VNode 树的称呼。</p></li> <li><p>createElement 参数<br>
3.1、深入 data 对象：正如在模板语法中，<code>v-bind:class</code>和 <code>v-bind:style</code> ，会被特别对待一样，在 VNode 数据对象中，下列属性名是级别最高的字段。该对象也允许你绑定普通的 HTML 特性，就像 DOM 属性一样，比如 innerHTML (这会取代 v-html 指令)。<br>
3.2、完整示例<br>
3.3、约束：组件树中的所有 VNodes 必须是唯一的。<br>
渲染了 20 个重复的段落：</p></li> <li><p>使用 JavaScript 代替模板功能<br>
4.1、v-if 和 v-for<br>
4.2、v-model：render 函数中没有与 v-model 相应的 api - 你必须自己来实现相应的逻辑：<br>
4.3、事件 &amp; 按键修饰符：对于 .passive、.capture 和 .once事件修饰符, Vue 提供了相应的前缀可以用于 on：</p> <div class="language- extra-class"><pre class="language-text"><code>    Modifier(s)     |Prefix
    ________________________
    .passive        |&amp;
    .capture        |!
    .once           |~
    .capture.once   |~!
    .once.capture   |~!
</code></pre></div><p>4.4、插槽:<br>
你可以从 this.$slots 获取 VNodes 列表中的静态内容：<br>
如果要用渲染函数向子组件中传递作用域插槽，可以利用 VNode 数据中的 scopedSlots 域：</p></li> <li><p>JSX:<br>
注意：将 h 作为 createElement 的别名是 Vue 生态系统中的一个通用惯例，实际上也是 JSX 所要求的，如果在作用域中 h 失去作用，在应用中会触发报错。</p></li> <li><p>函数式组件（无状态无data，无实例无this上下文）<br>
6.1、slots() 和 children 对比</p></li></ol> <h4 id="十六、插件"><a href="#十六、插件" class="header-anchor">#</a> 十六、插件</h4> <ol><li>开发插件：  插件通常会为 Vue 添加全局功能。插件的范围没有限制——一般有下面几种：<br>
1.1 添加全局方法或者属性，如: vue-custom-element<br>
1.2 添加全局资源：指令/过滤器/过渡等，如 vue-touch<br>
1.3 通过全局 mixin 方法添加一些组件选项，如: vue-router<br>
1.4添加 Vue 实例方法，通过把它们添加到 Vue.prototype 上实现。<br>
1.5 一个库，提供自己的 API，同时提供上面提到的一个或多个功能，如 vue-router</li></ol> <blockquote><p>Vue.js 的插件应当有一个公开方法 install 。这个方法的第一个参数是 Vue 构造器，第二个参数是一个可选的选项对象：</p></blockquote> <ol start="2"><li>使用插件<br>
2.1 通过全局方法 Vue.use() 使用插件：// 调用 <code>MyPlugin.install(Vue)</code><br>
2.2 <code>Vue.use(MyPlugin)</code><br>
2.3 也可以传入一个选项对象：<br>
2.4 <code>Vue.use(MyPlugin, { someOption: true })</code>
2.5 Vue.use 会自动阻止多次注册相同插件，届时只会注册一次该插件。</li></ol> <h4 id="十七、过滤器"><a href="#十七、过滤器" class="header-anchor">#</a> 十七、过滤器</h4> <blockquote><p>Vue.js 允许你自定义过滤器，可被用于一些常见的文本格式化。</p></blockquote> <ol><li>过滤器可以用在两个地方：双花括号插值和 v-bind 表达式 。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符号指示：</li> <li>可以在一个组件的选项中定义本地的过滤器：</li> <li>全局定义过滤器：</li> <li>过滤器可以串联：</li></ol> <div class="language-js extra-class"><pre class="language-js"><code>    <span class="token punctuation">{</span><span class="token punctuation">{</span> message <span class="token operator">|</span> filterA <span class="token operator">|</span> filterB <span class="token punctuation">}</span><span class="token punctuation">}</span>
    <span class="token comment">//将 filterA 的结果传递到 filterB 中。  </span>
</code></pre></div><ol start="5"><li>过滤器是 JavaScript 函数，因此可以接收参数：</li></ol> <div class="language-js extra-class"><pre class="language-js"><code>    <span class="token punctuation">{</span><span class="token punctuation">{</span> message <span class="token operator">|</span> <span class="token function">filterA</span><span class="token punctuation">(</span><span class="token string">'arg1'</span><span class="token punctuation">,</span> arg2<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">}</span>
</code></pre></div><blockquote><p>这里，filterA 被定义为接收三个参数的过滤器函数。其中 message 的值作为第一个参数，普通字符串 'arg1' 作为第二个参数，表达式 arg2 的值作为第三个参数。</p></blockquote> <p>工具</p> <h4 id="十八、生产环境部署"><a href="#十八、生产环境部署" class="header-anchor">#</a> 十八、生产环境部署</h4> <ol><li>开启生产环境模式：<br>
开发环境下，Vue 会提供很多警告来帮你对付常见的错误与陷阱。<br>
而在生产环境下，这些警告语句却没有用，反而会增加应用的体积。<br>
此外，有些警告检查还有一些小的运行时开销，这在生产环境模式下是可以避免的。<br>
1.1、不使用构建工具：如果用 Vue 完整独立版本，即直接用 <code>&lt;script&gt;</code> 元素引入 Vue 而不提前进行构建，请记得在生产环境下使用压缩后的版本 (vue.min.js)。<br>
1.2、使用构建工具</li> <li>模板预编译</li> <li>提取组件的 CSS</li> <li>跟踪运行时错误：如果在组件渲染时出现运行错误，错误将会被传递至全局<code>Vue.config.errorHandler</code>配置函数 (如果已设置)。利用这个钩子函数来配合错误跟踪服务是个不错的主意。</li></ol> <h4 id="十九、单文件组件"><a href="#十九、单文件组件" class="header-anchor">#</a> 十九、单文件组件</h4> <ol><li>介绍：在很多 Vue 项目中，我们使用 Vue.component 来定义全局组件，紧接着用 <code>new Vue({ el: '#container '})</code> 在每个页面内指定一个容器元素。<br>
缺点：</li></ol> <ul><li>全局定义 (Global definitions) ，强制要求每个 component 中的命名不得重复</li> <li>字符串模板 (String templates) ，缺乏语法高亮，在 HTML 有多行的时候，需要用到丑陋的</li> <li>不支持 CSS (No CSS support) ，意味着当 HTML 和 JavaScript 组件化时，CSS 明显被遗漏</li> <li>没有构建步骤 (No build step) ，限制只能使用 HTML 和 ES5 JavaScript, 而不能使用预处理器</li></ul> <ol start="2"><li>怎么看待关注点分离？</li></ol> <ul><li>一个重要的事情值得注意，关注点分离不等于文件类型分离。</li> <li>我们已经发现相比于把代码库分离成三个大的层次并将其相互交织起来，把它们划分为松散耦合的组件再将其组合起来更合理一些。</li> <li>在一个组件里，其模板、逻辑和样式是内部耦合的，并且把他们搭配在一起实际上使得组件更加内聚且更可维护。</li></ul> <h4 id="二十、路由"><a href="#二十、路由" class="header-anchor">#</a> 二十、路由</h4> <ul><li>hash模式：在浏览器中符号“#”，#以及#后面的字符称之为hash，用window.location.hash读取；<br>
特点：hash虽然在URL中，但不被包括在HTTP请求中；用来指导浏览器动作，对服务端安全无用，hash不会重加载页面。</li> <li>history模式：history采用HTML5的新特性；且提供了两个新方法：pushState（），replaceState（）可以对浏览器历史记录栈进行修改，以及popState事件的监听到状态变更。</li></ul> <h4 id="vue-router"><a href="#vue-router" class="header-anchor">#</a> Vue-router</h4> <p>active-class 是vue-router模块的router-link组件<br>
嵌套路由：路由对象的children属性可以定义子路由数组<br>
路由跳转</p> <ol><li>声明式（标签） <code>&lt;router-link :to=”index”&gt;</code></li> <li>编程式（js）<code>router.push(‘index’)</code></li></ol> <ul><li>懒加载（按需加载路由）</li></ul> <ol><li>webpack提供require.ensure()来实现按需加载<br>
2.使用 ()=&gt; import('modulePath') 导入 (import 返回一个promise)</li></ol> <p><strong>$route对象</strong> 是路由信息对象，包括path，params，hash，query，fullPath，matched，name<br> <strong>$router</strong> 是路由实例，包括路由跳转方法，钩子函数等<br> <strong>命名路由</strong> 路由配置里写name: ’a’<br> <strong>重定向</strong> 路由配置里写redirect:’’/b’<br> <strong>路由钩子函数</strong></p> <blockquote><p>路由守卫接收三个参数</p></blockquote> <ul><li><code>to</code>：Route 即将进入的目标路由对象</li> <li><code>from</code>：Route 当前导航正要离开的路由</li> <li><code>next</code>: Function 一定要调用该方法来resolve这个钩子，执行效果依赖于next方法调用参数</li> <li><code>next()</code>: 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed (确认的)。</li> <li><code>next(false)</code>: 中断当前的导航。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 from 路由对应的地址。</li> <li><code>next('/')</code> 或者<code>next({ path: '/' })</code>: 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向 next 传递任意位置对象，且允许设置诸如 replace: true、name: 'home' 之类的选项以及任何用在 router-link 的 to prop 或 router.push 中的选项。</li> <li><code>next(error)</code>: (2.4.0+) 如果传入 next 的参数是一个 Error 实例，则导航会被终止且该错误会被传递给 router.onError() 注册过的回调。<br> <strong>全局导航钩子</strong></li></ul> <ol><li><code>router.beforeEach(to,from,next)</code> 当一个导航被触发时，全局前置守卫按顺序被触发</li> <li><code>router.beforeResolve(to,from,next)</code> 导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫被调用</li> <li><code>router.afterEach(to,from)</code> 全局后置钩子<br> <strong>路由独享钩子</strong> <code>beforeEnter(to,from,next)</code> <strong>定义在路由配置</strong>上
<strong>组件内导航钩子</strong></li></ol></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/InterviewMap/css/" class="prev">
        px, em和rem区别
      </a></span> <span class="next"><a href="/InterviewMap/vue/component.html">
        手动挂载组件
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/InterviewMap/assets/js/app.7ef33b20.js" defer></script><script src="/InterviewMap/assets/js/2.c7a96f3a.js" defer></script><script src="/InterviewMap/assets/js/24.fdfbf9f3.js" defer></script>
  </body>
</html>
